#!/usr/bin/env python

# Reads an OONI http_requests report and shows URLs that have known block pages.
#
# First, make an OONI report:
#   ooniprobe -i /usr/share/ooni/decks/complete_no_root.deck
# Then,
#   ./findblocks report-http_requests-XXXX.yamloo

# Should look for timeout blocks.
# http://www.freedomhouse.org: control_failure=task_timed_out

import csv
import errno
import getopt
import gzip
import os
import os.path
import re
import sys
import urllib
import urlparse
import yaml

from bs4 import BeautifulSoup

# Return (is_block, description) tuple. 4?? and 5?? status codes are considered
# blocks.
def classify_blockpage(response):
    soup = BeautifulSoup(response["body"])
    title = soup.title
    code = response["code"]
    if code == 403 and title is not None and title.get_text() == u"Attention Required! | CloudFlare":
        return True, "403-CLOUDFLARE"
    if code == 403 and title is not None and re.match(ur'^M\d+-\d+$', title.get_text().strip()) and soup.iframe:
        return True, "403-IRAN"
    if code == 404 and title is not None and title == u"Access Denied" and re.search(r'You don\'t have permission to access ".*" on this server\.<P>', response["body"]):
        # Seen on www.foxnews.com. Server is AkamaiGHost.
        return True, "404-ACCESSDENIED"
    if code // 100 == 4 or code // 100 == 5:
        return True, "%d-OTHER" % code
    return False, "%d" % code

# Return a (nontor, tor) pair if there are exactly two requests and one is
# nontor and one is tor, or else raise an exception.
def split_requests(requests):
    nontor = None
    tor = None
    for request in requests:
        if request.get("failure") is not None:
            continue
        if not request["request"]["tor"]["is_tor"]:
            if nontor is not None:
                raise ValueError("more than one is_tor:false request")
            nontor = request
        else:
            if tor is not None:
                raise ValueError("more than one is_tor:true request")
            tor = request
    if nontor is None:
        raise ValueError("missing is_tor:false request")
    if tor is None:
        raise ValueError("missing is_tor:true request")
    return nontor, tor

def save_response(f, response):
    f.write("HTTP/1.0 %d xxx\r\n" % response["code"])
    for name, values in response["headers"]:
        for value in values:
            f.write("%s: %s\r\n" % (name, value))
    f.write("\r\n")
    # YAMLOO can give us either a binary string (type str) or a Unicode string
    # (type unicode, with unspecified original encoding) for the body. If it's
    # Unicode, guess the encoding was UTF-8. It might be possible to scrape the
    # Content-Type for the encoding.
    body = response["body"]
    if type(body) == unicode:
        body = body.encode("utf-8")
    f.write(body)

def save_response_filename(filename, response):
    try:
        os.makedirs(os.path.dirname(filename))
    except OSError, e:
        if e.errno != errno.EEXIST:
            raise
    with open(filename, "w") as f:
        return save_response(f, response)

def boolf(v):
    if v:
        return "T"
    else:
        return "F"

def make_save_filename(header, response, url, classname):
    url = urlparse.urlparse(url)
    return os.path.join("blocks", classname, urllib.quote("%s-%s%s" % (header["report_id"], url.netloc, url.path), safe=""))

def process_file(f):
    yamloo = yaml.safe_load_all(f)

    header = None
    for doc in yamloo:
        if doc["record_type"] == "header":
            assert header is None
            header = doc
            continue

        if doc["record_type"] != "entry":
            continue

        if doc["control_failure"] is not None:
            print >> sys.stderr, "%s: control_failure=%s" % (doc["input"], doc["control_failure"])
            continue
        if doc["experiment_failure"] is not None:
            print >> sys.stderr, "%s: experiment_failure=%s" % (doc["input"], doc["experiment_failure"])
            continue

        try:
            nontor, tor = split_requests(doc["requests"])
        except ValueError, e:
            print >> sys.stderr, "%s: %s" % (doc["input"], str(e))
            continue

        nontor_isblocked, nontor_class = classify_blockpage(nontor["response"])
        tor_isblocked, tor_class = classify_blockpage(tor["response"])

        csvw.writerow({
            "report_id": header["report_id"],
            "probe_cc": header["probe_cc"],
            "url": doc["input"],
            "nontor_isblocked": boolf(nontor_isblocked),
            "nontor_status": nontor["response"]["code"],
            "nontor_class": nontor_class,
            "tor_isblocked": boolf(tor_isblocked),
            "tor_status": tor["response"]["code"],
            "tor_class": tor_class,
        })
        sys.stdout.flush()

        if nontor_isblocked:
            save_response_filename(make_save_filename(header, nontor["response"], doc["input"], nontor_class), nontor["response"])
        if tor_isblocked:
            save_response_filename(make_save_filename(header, tor["response"], doc["input"], tor_class), tor["response"])

# Open a file optionally with gzip decompression based on the filename
# extension.
def magic_open(filename):
    if filename.endswith(".gz"):
        return gzip.GzipFile(filename)
    return open(filename)

def process_filename(filename):
    with magic_open(filename) as f:
        return process_file(f)

opts, args = getopt.gnu_getopt(sys.argv[1:], "")

csvw = csv.DictWriter(sys.stdout, fieldnames=["report_id", "probe_cc", "nontor_isblocked", "nontor_status", "nontor_class", "tor_isblocked", "tor_status", "tor_class", "url"], lineterminator="\n")
csvw.writeheader()

for filename in args:
    process_filename(filename)
